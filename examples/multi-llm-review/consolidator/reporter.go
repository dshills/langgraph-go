package consolidator

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/dshills/langgraph-go/examples/multi-llm-review/types"
)

// GenerateMarkdownReport creates a comprehensive markdown report from the review state.
// It follows the format specified in contracts/report-format.md and includes:
// - Header with metadata (codebase, timestamp, duration, files, issues, providers)
// - Summary statistics table (files reviewed, issues by severity)
// - By Category table (security, performance, best-practices, style)
// - Provider Statistics table (issues found, tokens used, duration)
// - Issues grouped by severity with provider attribution and consensus scores
// - Files reviewed section (files with issues, clean files)
// - Provider details section (status, statistics per provider)
// - Review timeline footer
func GenerateMarkdownReport(state types.ReviewState) string {
	var md strings.Builder

	// Calculate total providers from Reviews map
	totalProviders := len(state.Reviews)

	// Header with metadata
	writeHeader(&md, state, totalProviders)

	// Summary Statistics section (enhanced with tables)
	writeSummaryStatistics(&md, state)

	// Issues grouped by severity (with enhanced provider attribution)
	writeIssuesBySeverity(&md, state.ConsolidatedIssues, totalProviders)

	// Files Reviewed section
	writeFilesReviewed(&md, state)

	// Provider Details section
	writeProviderDetails(&md, state)

	// Timeline footer
	writeTimeline(&md, state)

	// Footer
	md.WriteString("---\n\n")
	md.WriteString("Generated by Multi-LLM Code Review Workflow\n")

	return md.String()
}

// writeHeader generates the report header with metadata
func writeHeader(md *strings.Builder, state types.ReviewState, totalProviders int) {
	md.WriteString("# Code Review Report\n\n")

	// Codebase root
	if state.CodebaseRoot != "" {
		md.WriteString(fmt.Sprintf("**Codebase**: %s\n", state.CodebaseRoot))
	}

	// Generated timestamp
	md.WriteString(fmt.Sprintf("**Generated**: %s\n", time.Now().Format(time.RFC3339)))

	// Duration (if start and end times available)
	if state.StartTime != "" && state.EndTime != "" {
		start, startErr := time.Parse(time.RFC3339, state.StartTime)
		end, endErr := time.Parse(time.RFC3339, state.EndTime)
		if startErr == nil && endErr == nil {
			duration := end.Sub(start)
			md.WriteString(fmt.Sprintf("**Duration**: %s\n", formatDuration(duration)))
		}
	}

	// Files reviewed
	md.WriteString(fmt.Sprintf("**Files Reviewed**: %d\n", state.TotalFilesReviewed))

	// Total issues
	md.WriteString(fmt.Sprintf("**Issues Found**: %d\n", len(state.ConsolidatedIssues)))

	// Providers list
	if totalProviders > 0 {
		providers := make([]string, 0, totalProviders)
		for provider := range state.Reviews {
			providers = append(providers, provider)
		}
		sort.Strings(providers)
		md.WriteString(fmt.Sprintf("**Providers**: %s\n", strings.Join(providers, ", ")))
	}

	md.WriteString("\n---\n\n")
}

// writeSummaryStatistics generates the summary statistics section with tables
func writeSummaryStatistics(md *strings.Builder, state types.ReviewState) {
	md.WriteString("## Summary Statistics\n\n")

	// Count issues by severity
	severityCounts := countBySeverity(state.ConsolidatedIssues)

	// Issues by severity table
	md.WriteString("| Metric | Count |\n")
	md.WriteString("|--------|-------|\n")
	md.WriteString(fmt.Sprintf("| Total Files Reviewed | %d |\n", state.TotalFilesReviewed))
	md.WriteString(fmt.Sprintf("| Critical Issues | %d |\n", severityCounts["critical"]))
	md.WriteString(fmt.Sprintf("| High Priority Issues | %d |\n", severityCounts["high"]))
	md.WriteString(fmt.Sprintf("| Medium Priority Issues | %d |\n", severityCounts["medium"]))
	md.WriteString(fmt.Sprintf("| Low Priority Issues | %d |\n", severityCounts["low"]))
	md.WriteString(fmt.Sprintf("| Informational Issues | %d |\n", severityCounts["info"]))
	md.WriteString(fmt.Sprintf("| **Total Issues** | **%d** |\n\n", len(state.ConsolidatedIssues)))

	// Count issues by category
	categoryCounts := countByCategory(state.ConsolidatedIssues)

	// By Category section
	md.WriteString("### By Category\n\n")
	md.WriteString("| Category | Count |\n")
	md.WriteString("|----------|-------|\n")
	md.WriteString(fmt.Sprintf("| Security | %d |\n", categoryCounts["security"]))
	md.WriteString(fmt.Sprintf("| Performance | %d |\n", categoryCounts["performance"]))
	md.WriteString(fmt.Sprintf("| Best Practices | %d |\n", categoryCounts["best-practice"]))
	md.WriteString(fmt.Sprintf("| Style | %d |\n\n", categoryCounts["style"]))

	// Provider Statistics section
	md.WriteString("### Provider Statistics\n\n")
	md.WriteString("| Provider | Issues Found | Tokens Used | Duration |\n")
	md.WriteString("|----------|--------------|-------------|----------|\n")

	// Collect provider statistics
	providerStats := collectProviderStatistics(state.Reviews)

	// Sort providers alphabetically
	providerNames := make([]string, 0, len(providerStats))
	for name := range providerStats {
		providerNames = append(providerNames, name)
	}
	sort.Strings(providerNames)

	// Output provider rows
	for _, name := range providerNames {
		stats := providerStats[name]
		md.WriteString(fmt.Sprintf("| %s | %d | %s | %s |\n",
			name,
			stats.IssuesFound,
			formatNumber(stats.TokensUsed),
			formatDuration(time.Duration(stats.DurationMS)*time.Millisecond)))
	}

	md.WriteString("\n---\n\n")
}

// writeIssuesBySeverity generates sections for each severity level
func writeIssuesBySeverity(md *strings.Builder, issues []types.ConsolidatedIssue, totalProviders int) {
	// Group issues by severity
	issuesBySeverity := make(map[string][]types.ConsolidatedIssue)
	for _, issue := range issues {
		severity := issue.Severity
		if severity == "" {
			severity = "info"
		}
		issuesBySeverity[severity] = append(issuesBySeverity[severity], issue)
	}

	// Severity order for output
	severityOrder := []struct {
		key   string
		title string
		emoji string
	}{
		{"critical", "Critical Issues", " ðŸ“Œ"},
		{"high", "High Priority Issues", ""},
		{"medium", "Medium Priority Issues", ""},
		{"low", "Low Priority Issues", ""},
		{"info", "Informational Issues", ""},
	}

	issueCounter := 1

	// Generate sections for each severity level
	for _, sev := range severityOrder {
		issues := issuesBySeverity[sev.key]
		count := len(issues)

		// Section header with count
		md.WriteString(fmt.Sprintf("## %s (%d)\n\n", sev.title, count))

		if count == 0 {
			// Show "No X issues found" for empty sections
			md.WriteString(fmt.Sprintf("No %s found.\n\n", strings.ToLower(sev.title)))
		} else {
			// Output each issue in this severity level
			for _, issue := range issues {
				writeIssue(md, issue, issueCounter, sev.emoji, totalProviders)
				issueCounter++
			}
		}

		md.WriteString("---\n\n")
	}
}

// writeIssue generates markdown for a single issue with enhanced provider attribution
func writeIssue(md *strings.Builder, issue types.ConsolidatedIssue, number int, emoji string, totalProviders int) {
	// Issue heading with number and optional emoji
	md.WriteString(fmt.Sprintf("### %d. %s%s\n\n", number, issue.Description, emoji))

	// File and line
	md.WriteString(fmt.Sprintf("**File**: `%s:%d`\n", issue.File, issue.Line))

	// Severity
	md.WriteString(fmt.Sprintf("**Severity**: %s\n", capitalizeFirst(issue.Severity)))

	// Category
	md.WriteString(fmt.Sprintf("**Category**: %s\n", formatCategoryName(issue.Category)))

	// Providers (sorted alphabetically)
	if len(issue.Providers) > 0 {
		md.WriteString(fmt.Sprintf("**Providers**: %s\n", strings.Join(issue.Providers, ", ")))
	}

	// Consensus score with provider count (e.g., "2/3 providers (67%)")
	if totalProviders > 0 && issue.ConsensusScore > 0 {
		providerCount := len(issue.Providers)
		percentage := int(issue.ConsensusScore * 100)
		md.WriteString(fmt.Sprintf("**Consensus**: %d/%d providers (%d%%)\n",
			providerCount, totalProviders, percentage))
	}

	md.WriteString("\n")

	// Remediation
	if issue.Remediation != "" {
		md.WriteString("**Remediation**:\n")
		md.WriteString(fmt.Sprintf("%s\n", issue.Remediation))
	}

	md.WriteString("\n")
}

// writeFilesReviewed generates the files reviewed section
func writeFilesReviewed(md *strings.Builder, state types.ReviewState) {
	md.WriteString("## Files Reviewed\n\n")

	// Count issues per file
	issuesByFile := make(map[string]int)
	for _, issue := range state.ConsolidatedIssues {
		issuesByFile[issue.File]++
	}

	// Separate files into clean and with issues
	var cleanFiles []string
	var filesWithIssues []struct {
		path  string
		count int
	}

	for _, file := range state.DiscoveredFiles {
		if count, hasIssues := issuesByFile[file.FilePath]; hasIssues {
			filesWithIssues = append(filesWithIssues, struct {
				path  string
				count int
			}{file.FilePath, count})
		} else {
			cleanFiles = append(cleanFiles, file.FilePath)
		}
	}

	// Sort both lists
	sort.Strings(cleanFiles)
	sort.Slice(filesWithIssues, func(i, j int) bool {
		return filesWithIssues[i].path < filesWithIssues[j].path
	})

	// Output files with issues
	if len(filesWithIssues) > 0 {
		md.WriteString("### Files with Issues\n\n")
		for _, file := range filesWithIssues {
			md.WriteString(fmt.Sprintf("- `%s` - %d issue(s)\n", file.path, file.count))
		}
		md.WriteString("\n")
	}

	// Output clean files
	if len(cleanFiles) > 0 {
		md.WriteString("### Clean Files (No Issues)\n\n")
		for _, file := range cleanFiles {
			md.WriteString(fmt.Sprintf("- `%s`\n", file))
		}
		md.WriteString("\n")
	}

	md.WriteString("---\n\n")
}

// writeProviderDetails generates the provider details section
func writeProviderDetails(md *strings.Builder, state types.ReviewState) {
	md.WriteString("## Provider Details\n\n")

	// Sort provider names
	providerNames := make([]string, 0, len(state.Reviews))
	for name := range state.Reviews {
		providerNames = append(providerNames, name)
	}
	sort.Strings(providerNames)

	// Output details for each provider
	for _, name := range providerNames {
		reviews := state.Reviews[name]
		if len(reviews) == 0 {
			continue
		}

		// Aggregate statistics across all reviews from this provider
		totalIssues := 0
		totalTokens := 0
		totalDuration := int64(0)
		hasError := false
		errorMsg := ""

		for _, review := range reviews {
			totalIssues += len(review.Issues)
			totalTokens += review.TokensUsed
			totalDuration += review.Duration
			if review.Error != "" {
				hasError = true
				errorMsg = review.Error
			}
		}

		// Provider heading
		md.WriteString(fmt.Sprintf("### %s\n\n", capitalizeFirst(name)))

		// Status
		if hasError {
			md.WriteString("- **Status**: Failed âœ—\n")
			md.WriteString(fmt.Sprintf("- **Error**: %s\n", errorMsg))
		} else {
			md.WriteString("- **Status**: Success âœ“\n")
		}

		// Statistics
		md.WriteString(fmt.Sprintf("- **Issues Found**: %d\n", totalIssues))
		md.WriteString(fmt.Sprintf("- **Tokens Used**: %s\n", formatNumber(totalTokens)))
		md.WriteString(fmt.Sprintf("- **Duration**: %s\n",
			formatDuration(time.Duration(totalDuration)*time.Millisecond)))

		md.WriteString("\n")
	}

	md.WriteString("---\n\n")
}

// writeTimeline generates the timeline footer section
func writeTimeline(md *strings.Builder, state types.ReviewState) {
	if state.StartTime == "" {
		return
	}

	md.WriteString("## Review Timeline\n\n")
	md.WriteString(fmt.Sprintf("- **Started**: %s\n", state.StartTime))
	if state.EndTime != "" {
		md.WriteString(fmt.Sprintf("- **Completed**: %s\n", state.EndTime))

		// Calculate duration if both timestamps are present
		startTime, err1 := time.Parse(time.RFC3339, state.StartTime)
		endTime, err2 := time.Parse(time.RFC3339, state.EndTime)
		if err1 == nil && err2 == nil {
			duration := endTime.Sub(startTime)
			md.WriteString(fmt.Sprintf("- **Duration**: %s\n\n", formatDuration(duration)))
		}
	}
}

// Helper functions

// countBySeverity counts consolidated issues by severity level
func countBySeverity(issues []types.ConsolidatedIssue) map[string]int {
	counts := make(map[string]int)
	for _, issue := range issues {
		severity := issue.Severity
		if severity == "" {
			severity = "info"
		}
		counts[severity]++
	}
	return counts
}

// countByCategory counts consolidated issues by category
func countByCategory(issues []types.ConsolidatedIssue) map[string]int {
	counts := make(map[string]int)
	for _, issue := range issues {
		counts[issue.Category]++
	}
	return counts
}

// providerStatistics holds aggregated statistics for a provider
type providerStatistics struct {
	IssuesFound int
	TokensUsed  int
	DurationMS  int64
}

// collectProviderStatistics aggregates statistics from all reviews per provider
func collectProviderStatistics(reviews map[string][]types.Review) map[string]providerStatistics {
	stats := make(map[string]providerStatistics)

	for providerName, providerReviews := range reviews {
		var s providerStatistics
		for _, review := range providerReviews {
			s.IssuesFound += len(review.Issues)
			s.TokensUsed += review.TokensUsed
			s.DurationMS += review.Duration
		}
		stats[providerName] = s
	}

	return stats
}

// formatNumber formats integers with comma separators (e.g., 12,500)
func formatNumber(n int) string {
	if n < 1000 {
		return fmt.Sprintf("%d", n)
	}

	// Convert to string and add commas
	s := fmt.Sprintf("%d", n)
	result := ""
	for i, c := range s {
		if i > 0 && (len(s)-i)%3 == 0 {
			result += ","
		}
		result += string(c)
	}
	return result
}

// formatDuration formats a duration in a human-readable format
func formatDuration(d time.Duration) string {
	seconds := d.Seconds()
	if seconds < 1 {
		return fmt.Sprintf("%.3fs", seconds)
	}
	if seconds < 60 {
		return fmt.Sprintf("%.1fs", seconds)
	}
	minutes := int(seconds / 60)
	remainingSeconds := int(seconds) % 60
	if minutes < 60 {
		return fmt.Sprintf("%dm %ds", minutes, remainingSeconds)
	}
	hours := minutes / 60
	remainingMinutes := minutes % 60
	return fmt.Sprintf("%dh %dm", hours, remainingMinutes)
}

// capitalizeFirst capitalizes the first letter of a string
func capitalizeFirst(s string) string {
	if s == "" {
		return ""
	}
	// Convert first character to uppercase properly
	firstChar := s[0]
	if firstChar >= 'a' && firstChar <= 'z' {
		firstChar = firstChar - 32
	}
	return string(firstChar) + s[1:]
}

// formatCategoryName formats category names for display
func formatCategoryName(category string) string {
	switch category {
	case "security":
		return "Security"
	case "performance":
		return "Performance"
	case "best-practice":
		return "Best Practices"
	case "style":
		return "Style"
	default:
		return capitalizeFirst(category)
	}
}
